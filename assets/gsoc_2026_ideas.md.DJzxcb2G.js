import{_ as i,o as t,c as s,ae as a}from"./chunks/framework.9XX48Qcy.js";const g=JSON.parse('{"title":"Project Ideas","description":"","frontmatter":{},"headers":[],"relativePath":"gsoc/2026/ideas.md","filePath":"en/gsoc/2026/ideas.md"}'),n={name:"gsoc/2026/ideas.md"};function l(o,e,r,p,h,c){return t(),s("div",null,[...e[0]||(e[0]=[a(`<h1 id="project-ideas" tabindex="-1">Project Ideas <a class="header-anchor" href="#project-ideas" aria-label="Permalink to &quot;Project Ideas&quot;">​</a></h1><h2 id="comprehensive-suite-of-code-actions-refactorings" tabindex="-1">Comprehensive Suite of Code Actions &amp; Refactorings <a class="header-anchor" href="#comprehensive-suite-of-code-actions-refactorings" aria-label="Permalink to &quot;Comprehensive Suite of Code Actions &amp; Refactorings&quot;">​</a></h2><h3 id="abstract" tabindex="-1">Abstract <a class="header-anchor" href="#abstract" aria-label="Permalink to &quot;Abstract&quot;">​</a></h3><p>Modern development isn&#39;t just about writing code; it&#39;s about evolving it. Code Actions (Quick Fixes and Refactorings) are essential for developer productivity, automating tedious tasks like generating boilerplate, fixing compilation errors, or restructuring logic.</p><p>This project focuses on building a rich library of Code Actions for clice. The goal is to port essential features from existing tools (like Clangd) and implement new, innovative refactorings that leverage our server&#39;s architecture, transforming it into a powerful assistant for C++ developers.</p><h3 id="the-problem" tabindex="-1">The Problem <a class="header-anchor" href="#the-problem" aria-label="Permalink to &quot;The Problem&quot;">​</a></h3><p>Currently, clice has a basic infrastructure for Code Actions but lacks the breadth of features found in mature IDEs. Developers still have to manually copy-paste function signatures to create definitions, manually fill out <code>switch</code> statements, or rewrite generic code by hand. This breaks the &quot;Flow&quot; state and introduces human error.</p><h3 id="project-goals" tabindex="-1">Project Goals <a class="header-anchor" href="#project-goals" aria-label="Permalink to &quot;Project Goals&quot;">​</a></h3><p>The project is divided into three tiers of complexity:</p><ol><li><p><strong>Essential &quot;Quick Fixes&quot; (The Basics):</strong></p><ul><li><strong>Create Definition:</strong> Automatically generate the function body in a <code>.cpp</code> file based on a declaration in a <code>.h</code> file (handling namespaces and class qualifiers correctly).</li><li><strong>Add Include:</strong> If a type is unknown, suggest inserting the correct <code>#include</code>.</li><li><strong>Populate Switch:</strong> Automatically generate <code>case</code> statements for all values of an <code>enum</code> in a switch block.</li></ul></li><li><p><strong>Structural Refactorings (Intermediate):</strong></p><ul><li><strong>Extract Variable:</strong> Turn a complex expression into a local variable.</li><li><strong>Invert if-statement:</strong> Flip the logic of an <code>if-else</code> block (e.g., <code>if (a) { x } else { y }</code> $\\to$ <code>if (!a) { y } else { x }</code>).</li><li><strong>Raw String Literals:</strong> Convert standard string escaping to C++11 Raw String Literals (and vice-versa).</li><li><strong>Auto to Explicit:</strong> Toggle between <code>auto</code> and the concrete type name.</li></ul></li><li><p><strong>Infrastructure &amp; Polish:</strong></p><ul><li>Ensure all actions respect the user&#39;s formatting style (e.g., clang-format).</li><li>Implement &quot;Selection-based&quot; triggers (actions that only appear when specific code is highlighted).</li><li>Optimize the &quot;Tweak&quot; framework to allow easy addition of future actions.</li></ul></li></ol><h3 id="technical-details" tabindex="-1">Technical Details <a class="header-anchor" href="#technical-details" aria-label="Permalink to &quot;Technical Details&quot;">​</a></h3><ul><li><strong>AST Traversal:</strong> The student will use the Clang AST to identify &quot;trigger points&quot; (e.g., is the cursor on an <code>enum</code> inside a <code>switch</code>?).</li><li><strong>Source Editing:</strong> Calculating the precise <code>TextEdit</code> operations (line/column replacements) without breaking surrounding code.</li><li><strong>Porting &amp; Adaptation:</strong> Much of the logic can be referenced from LLVM&#39;s Clangd (<code>clang-tools-extra/clangd/refactor/tweaks</code>), but it needs to be adapted to clice&#39;s specific AST management and threading model.</li></ul><h3 id="example-scenarios" tabindex="-1">Example Scenarios <a class="header-anchor" href="#example-scenarios" aria-label="Permalink to &quot;Example Scenarios&quot;">​</a></h3><p><strong>Scenario A: Populate Switch</strong><em>Before:</em></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GREEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BLUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Color c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RED;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Cursor here</span></span></code></pre></div><p><em>After Action:</em></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GREEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BLUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Scenario B: Create Definition</strong><em>Header:</em></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Trigger here</span></span></code></pre></div><p><em>Source (Automatically updated):</em></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // TODO: implementation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="expected-outcomes" tabindex="-1">Expected Outcomes <a class="header-anchor" href="#expected-outcomes" aria-label="Permalink to &quot;Expected Outcomes&quot;">​</a></h3><ul><li>Implementation of at least 5-8 high-value Code Actions (priority on <em>Create Definition</em> and <em>Populate Switch</em>).</li><li>A unified framework for registering and testing new actions.</li><li>Unit tests ensuring that code modifications are syntactically correct.</li></ul><h3 id="skills-required" tabindex="-1">Skills Required <a class="header-anchor" href="#skills-required" aria-label="Permalink to &quot;Skills Required&quot;">​</a></h3><ul><li><strong>C++ Proficiency:</strong> Comfortable with modern C++ standards.</li><li><strong>AST Manipulation:</strong> Understanding of how source code is represented as a tree (Clang AST experience preferred but can be learned).</li><li><strong>Attention to Detail:</strong> Handling edge cases (macros, templates, comments) is crucial for refactoring tools.</li></ul><h3 id="difficulty" tabindex="-1">Difficulty <a class="header-anchor" href="#difficulty" aria-label="Permalink to &quot;Difficulty&quot;">​</a></h3><p><strong>Medium</strong>. The logic for many of these actions is well-documented in the Clang community, making this an excellent project for students who want to get their hands dirty with Compiler Frontends without needing deep theoretical background in type systems.</p><h3 id="mentors" tabindex="-1">Mentors <a class="header-anchor" href="#mentors" aria-label="Permalink to &quot;Mentors&quot;">​</a></h3><ul><li><a href="https://github.com/16bit-ykiko" target="_blank" rel="noreferrer">ykiko</a></li><li><a href="https://github.com/Myriad-Dreamin" target="_blank" rel="noreferrer">Myriad-Dreamin</a></li></ul><h2 id="intelligent-code-completion-for-c-templates-via-heuristic-type-resolution" tabindex="-1">Intelligent Code Completion for C++ Templates via Heuristic Type Resolution <a class="header-anchor" href="#intelligent-code-completion-for-c-templates-via-heuristic-type-resolution" aria-label="Permalink to &quot;Intelligent Code Completion for C++ Templates via Heuristic Type Resolution&quot;">​</a></h2><h3 id="abstract-1" tabindex="-1">Abstract <a class="header-anchor" href="#abstract-1" aria-label="Permalink to &quot;Abstract&quot;">​</a></h3><p>C++ templates are notoriously difficult for language servers to handle. When writing code inside an uninstantiated template, tools usually fail to provide code completion, go-to-definition, or hover information because the types are &quot;dependent&quot; on unknown template arguments.</p><p>This project aims to implement and perfect a <strong>Heuristic Type Resolver</strong> for clice. By assuming the primary template definition and simulating template argument substitution, we can provide rich IntelliSense features inside templates, significantly improving the developer experience for generic programming.</p><h3 id="the-problem-1" tabindex="-1">The Problem <a class="header-anchor" href="#the-problem-1" aria-label="Permalink to &quot;The Problem&quot;">​</a></h3><p>Consider the following C++ code:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Wrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Issue: Language servers usually don&#39;t know what &#39;container[0]&#39; returns here.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // It returns a dependent type (e.g., std::vector&lt;T&gt;&amp;), so completion fails.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        container[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>In standard compilation, the compiler cannot know the members of <code>container[0]</code> until <code>Wrapper</code> is instantiated with a concrete type (due to potential template specializations). However, 99% of the time, users expect the tool to assume the <strong>primary template</strong> definition is used.</p><p>See also <a href="https://github.com/clangd/clangd/issues/443" target="_blank" rel="noreferrer">improve code completion inside templates</a> and <a href="https://discourse.llvm.org/t/pseudo-template-instantiation-in-clang/81406" target="_blank" rel="noreferrer">pseudo Template Instantiation in clang</a>.</p><h3 id="current-status" tabindex="-1">Current Status <a class="header-anchor" href="#current-status" aria-label="Permalink to &quot;Current Status&quot;">​</a></h3><p>We have a prototype/demo implementation ported from experimental Clangd patches. It implements a basic <code>TemplateResolver</code> capable of:</p><ol><li>Recursively simplifying nested <code>DependentNameType</code>.</li><li>Performing basic &quot;Find and Replace&quot; of template parameters within the AST to deduce probable types.</li></ol><p>However, the current implementation is a proof-of-concept and lacks support for complex C++ features, leading to failures in real-world STL usage.</p><h3 id="project-goals-the-scope" tabindex="-1">Project Goals (The Scope) <a class="header-anchor" href="#project-goals-the-scope" aria-label="Permalink to &quot;Project Goals (The Scope)&quot;">​</a></h3><p>The student will work on robustifying the Template Resolver. Key tasks include:</p><ol><li><p><strong>Enhance Recursive Simplification:</strong></p><ul><li>Improve the logic to unwrap complex nested types (e.g., <code>typename A&lt;T&gt;::B::type</code>).</li><li>Implement logic to &quot;see through&quot; standard type aliases (like <code>std::vector&lt;T&gt;::reference</code> $\\to$ <code>T&amp;</code>).</li></ul></li><li><p><strong>Handle Edge Cases in Template Instantiation:</strong></p><ul><li><strong>Default Template Arguments:</strong> Correctly handle cases like <code>template &lt;typename T, typename U = int&gt;</code> where <code>U</code> might be implicit.</li><li><strong>Variadic Templates:</strong> Support argument unpacking for <code>template &lt;typename... Args&gt;</code>.</li><li><strong>Depth Mismatch:</strong> Fix existing bugs where nested template depths cause deduction failures (as discussed in previous research).</li></ul></li><li><p><strong>LSP Feature Integration:</strong></p><ul><li>Ensure the resolved types flow correctly into Code Completion, Hover, and Go-to-Definition services.</li><li>Provide &quot;Inlay Hints&quot; for dependent variables to show users what the tool <em>thinks</em> the type is.</li></ul></li></ol><h3 id="technical-details-approach" tabindex="-1">Technical Details &amp; Approach <a class="header-anchor" href="#technical-details-approach" aria-label="Permalink to &quot;Technical Details &amp; Approach&quot;">​</a></h3><p>The core of this project involves manipulating the Clang AST (assuming your server is Clang-based) without triggering full template instantiation.</p><ul><li><strong>Heuristic Strategy:</strong> Instead of waiting for a concrete <code>T</code>, we treat <code>T</code> as a placeholder and symbolically execute lookups on the primary template <code>std::vector</code>.</li><li><strong>Mechanism:</strong><ul><li>Locate the primary template declaration.</li><li>Map the provided arguments to parameters.</li><li>Use <code>Sema</code> or custom logic to substitute types (e.g., transforming <code>std::vector&lt;T&gt;::iterator</code> into the actual iterator class definition).</li></ul></li></ul><h3 id="expected-outcomes-1" tabindex="-1">Expected Outcomes <a class="header-anchor" href="#expected-outcomes-1" aria-label="Permalink to &quot;Expected Outcomes&quot;">​</a></h3><ul><li>A robust <code>HeuristicResolver</code> module integrated into clice.</li><li>Working code completion for common STL containers (vector, map) inside template functions.</li><li>A comprehensive test suite covering nested templates, type aliases, and default arguments.</li></ul><h3 id="skills-required-1" tabindex="-1">Skills Required <a class="header-anchor" href="#skills-required-1" aria-label="Permalink to &quot;Skills Required&quot;">​</a></h3><ul><li><strong>Advanced C++:</strong> Familiarity with Template Metaprogramming (SFINAE, partial specialization).</li><li><strong>Compiler Frontend Knowledge:</strong> Understanding of Abstract Syntax Trees (AST), Types (Dependent vs. Concrete), and basic Lookup rules. (Experience with Clang AST is a huge plus).</li><li><strong>Problem Solving:</strong> Ability to debug complex recursive algorithms.</li></ul><h3 id="difficulty-1" tabindex="-1">Difficulty <a class="header-anchor" href="#difficulty-1" aria-label="Permalink to &quot;Difficulty&quot;">​</a></h3><p><strong>Hard</strong>. This involves deep dives into the C++ type system and handling cases where the standard &quot;rules&quot; of C++ compilation must be bent to provide a good user experience.</p><h3 id="mentors-1" tabindex="-1">Mentors <a class="header-anchor" href="#mentors-1" aria-label="Permalink to &quot;Mentors&quot;">​</a></h3><ul><li><a href="https://github.com/16bit-ykiko" target="_blank" rel="noreferrer">ykiko</a></li></ul>`,56)])])}const k=i(n,[["render",l]]);export{g as __pageData,k as default};
